#!/usr/bin/env node

var path = require("path"),
    exec = require("child_process").exec,
    _ = require("../lib/extended"),
    fs = require("fs"),
    existsSync = fs.existsSync || path.existsSync,
    it = require("../index"),
    Module = require("module").Module,
    _require = Module.prototype.require,
    program = require('commander'),
    coverage = {
        coverage: require("../lib/formatters/coverage"),
        coverageHtml: require("../lib/formatters/coverage-html")
    };

//ensure then we call get the same it
_(Module).extend({
    require: function require(mod) {
        if (mod === "it") {
            return it;
        } else {
            return _require.apply(this, arguments);
        }
    }
});

program
    .version('0.0.1')
    .option('-d, --directory <path>', 'Directory of tests')
    .option('-e, --env [string]', 'environment')
    .option('-r, --reporter [string]', 'reporter')
    .option('-f, --filter [string]', "filter")
    .option('-c, --config <path>', 'config')
    .option('--cov-html [path]', 'create coverage output in html')
    .option('--reporters', 'display available reporters')
    .on("reporters", function () {
        console.log(["", "Reporters:", "\tspec", "\tdotmatrix", ""].join("\n"));
        process.exit();
    })
    .parse(process.argv);

var directory, filter, prog, reporter, covType = "coverage", covOut = null;
prog = program.args.shift() || null;
function setupEnv(config) {
    var env = config.environment;
    if (env) {
        process.env.NODE_ENV = env;
    } else if (!process.env.NODE_ENV) {
        process.env.NODE_ENV = "test";
    }
    filter = config.filter || null;
    directory = config.directory || process.cwd() + "/test";
    reporter = config.reporter || "spec";
    if (config.covHtml) {
        covType = "coverageHtml";
        if (!_.isBoolean(config.covHtml)) {
            covOut = config.covHtml;
        }
    }
}

setupEnv(program);
var configFile = program.config || path.resolve(directory || path.resolve(process.cwd(), "./test"), "it.config");

try {
    config = require(configFile);
    setupEnv(config);
} catch (e) {
}


if (existsSync(directory)) {

    function runTests(files) {
        it.reporter(reporter);
        files.forEach(function (f) {
            require(f);
        });
        return it.run(filter);
    }

    function startTests() {
        var ret = new _.Promise();
        if (prog) {
            console.log(prog);
            runTests(prog.split(",").map(function (p) {
                return path.resolve(p);
            })).then(ret);
        } else {
            exec("find \"" + directory + "\" -name *.test.js", function (err, stdout) {
                if (err) {
                    ret.errback(err);
                } else {
                    var files = _(stdout.split("\n")).map(function (f) {
                        if (f !== '') {
                            return path.resolve(f);
                        }
                    }).compact().value();
                    if (files.length) {
                        runTests(files).then(ret.callback, ret.errback);
                    } else {
                        ret.callback();
                    }
                }
            });
        }
        return ret;
    }


    var orig = process.emit;
    process.emit = function (event) {
        if (event === 'exit') {
            if (typeof _$jscoverage === 'object') {
                coverage[covType].showCoverage(_$jscoverage, covOut);
            }
            orig.apply(this, arguments);
        } else {
            orig.apply(this, arguments);
        }
    };
    startTests().then(
        function (code) {
            process.exit(code);
        },
        function (error) {
            console.log(error);
            process.exit(1);
        }
    );
} else {
    console.error("No test directory found");
    process.exit(1);
}



